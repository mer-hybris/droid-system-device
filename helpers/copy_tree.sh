#!/bin/bash

#
# Before running this script please extract raw images and mount them.
# Pass them as parameters to this script.
#
# 1. "simg2img system.img system.raw"
# 2. "simg2img vendor.img vendor.raw"
# Optional (only if device supports system_ext and product):
#      "simg2img system_ext.img system_ext.raw"
#      "simg2img product.img product.raw"
# 3. "mkdir ~/system ~/vendor"
# Optional (only if device supports system_ext and product):
#      "mkdir ~/system_ext"
#      "mkdir ~/product"
# 4. "sudo mount -t ext4 -o loop system.raw ~/system"
# 5. "sudo mount -t ext4 -o loop vendor.raw ~/vendor"
# Optional (only if device supports system_ext and product):
#      "sudo mount -t ext4 -o loop system_ext.raw ~/system_ext"
#      "sudo mount -t ext4 -o loop product.raw ~/product"
#      "simg2img product.img product.raw"
# 6. "droid-system-device/helpers/copy_tree.sh ~/system ~/vendor rpm/spec-to-modify.spec"
# Optional (only if device supports system_ext and product):
#      "droid-system-device/helpers/copy_tree.sh ~/system ~/vendor ~/system_ext ~/product rpm/spec-to-modify.spec"
#

if [ $# -lt 2 ]; then
  echo "Usage: droid-system-device/helpers/$(basename "$0") path/to/tree1 ... rpm/spec-to-modify.spec"
  exit
fi

get_closest() {
    if [ -f "$1" ]; then
        echo "$1"
    elif [ -f droid-system-device/"$1" ]; then
        echo droid-system-device/"$1"
    else
        echo /dev/null
    fi
}

BUILD_HOST=
BUILD_USER=
fixup_buildprop() {
    if [ -f "$1" ]; then
        # pray that these are unique enough.
        if [ -n "$BUILD_HOST" ] && [ -n "$BUILD_HOST_REPLACEMENT" ]; then
            sed -i "s/$BUILD_HOST/$BUILD_HOST_REPLACEMENT/g" "$1"
        fi
        if [ -n "$BUILD_USER" ] && [ -n "$BUILD_USER_REPLACEMENT" ]; then
            sed -i "s/$BUILD_USER/$BUILD_USER_REPLACEMENT/g" "$1"
            sed -i "s/${BUILD_USER:0:6}/${BUILD_USER_REPLACEMENT:0:6}/g" "$1"
        fi
    fi
}

SPARSE=sparse

arg=""
trees=()
for var in "$@"; do
    if [ -n "$arg" ]; then
        trees+=("$arg")
    fi
    arg=$var
done

modify_spec=$(readlink -f "$arg")
post_rules=$(mktemp)

token="# rest of this file is autogenerated. do not edit"
sed -i "/$token/,\$d" "$modify_spec"
echo "$token" >> "$modify_spec"
echo "%post" >> "$modify_spec"

BUILD_HOST_REPLACEMENT=$(grep "%define build_host_replacement" "$modify_spec" | cut -d ' ' -f3)
BUILD_USER_REPLACEMENT=$(grep "%define build_user_replacement" "$modify_spec" | cut -d ' ' -f3)

if [[ ( -n "$BUILD_HOST_REPLACEMENT" || -n "$BUILD_USER_REPLACEMENT" ) \
      && ${trees[0]//\//} != *system ]]; then
    echo "Make sure to pass .../system (avoid final slash) argument first to this script,"
    echo "this is needed for removing the ro.build.host and ro.build.user properly from"
    echo ".../vendor."
    exit 1
fi

for tree_mount in "${trees[@]}"; do

TREE=$(basename "$tree_mount")
TREE_MOUNT=$tree_mount
TREE_SPARSE=$SPARSE/$TREE

# Add read permission for some binaries under mount
source "$(get_closest helpers/fixup-permissions-"$TREE".sh)"

# Remove current sparse and create it again
rm -rf "$TREE_SPARSE"
mkdir -p "$TREE_SPARSE"

# Copy content
echo "Copy $TREE_MOUNT/* to $TREE_SPARSE"
rsync -a --exclude="lost+found" "$TREE_MOUNT"/* "$TREE_SPARSE"

pushd "$TREE_MOUNT" 1>/dev/null || exit
find . \( -uid +0 -or -gid +0 \) -and \( -type f -or -type d -or -type s \) -printf "[ -e /$TREE/%P ] && chown %U:%G /$TREE/%P ||:\n" 2>/dev/null | LC_ALL="C" sort > "$post_rules"
popd 1>/dev/null || exit

if [ "$(wc -l < "$post_rules")" -gt 0 ]; then
  echo "Updating $modify_spec"
  cat "$post_rules" >> "$modify_spec"
fi
rm -f "$post_rules"

pushd "$TREE_MOUNT" 1>/dev/null || exit
find . -exec getcap {} + 2>/dev/null | awk -v tree="$TREE" '{ print "[ -e /"tree"/"$1" ] && " "setcap", $3, "/"tree"/"$1 }' | LC_COLLATE="C" sort >> "$modify_spec"
popd 1>/dev/null || exit

# Remove generic unused directories and files
source "$(get_closest helpers/remove-unused-"$TREE".sh)"

# General patches
echo "Apply general patches:"
source droid-system-device/helpers/general-patches.sh


if [ -z "$BUILD_HOST" ]; then
    BUILD_HOST=$(grep ro.build.host "$TREE_SPARSE"/build.prop | cut -d '=' -f2)
fi
if [ -z "$BUILD_USER" ]; then
    BUILD_USER=$(grep ro.build.user "$TREE_SPARSE"/build.prop | cut -d '=' -f2)
fi

fixup_buildprop "$TREE_SPARSE"/build.prop
fixup_buildprop "$TREE_SPARSE"/etc/prop.default
fixup_buildprop "$TREE_SPARSE"/odm/etc/build.prop

# Move build.prop to proper place if spec file has multiple_rpms definition
if grep -q "%define multiple_rpms 1" "$modify_spec"; then
    if [ "$TREE" = "system" ]; then
        if [ -f "$TREE_SPARSE"/build.prop ]; then
            DEVICE=$(grep ro.product.name "$TREE_SPARSE"/build.prop | cut -d '_' -f2)
            if [ -z "$DEVICE" ]; then
                DEVICE=$(grep ro.product.system.name "$TREE_SPARSE"/build.prop | cut -d '_' -f2)
            fi
            if [ -z "$DEVICE" ]; then
                echo "Could not parse device name from $TREE_SPARSE/build.prop"
                exit 1
            fi
            mkdir -p "$DEVICE"/system
            mv "$TREE_SPARSE"/build.prop "$DEVICE"/system
            if [ -f "$TREE_SPARSE"/etc/prop.default ]; then
                mkdir -p "$DEVICE"/system/etc
                mv "$TREE_SPARSE"/etc/prop.default "$DEVICE"/system/etc/prop.default
            fi
        fi
    elif [ "$TREE" = "product" ] || [ "$TREE" = "vendor" ]; then
        if [ -f "$TREE_SPARSE"/build.prop ]; then
            DEVICE=$(grep ro."$TREE".product.name "$TREE_SPARSE"/build.prop | cut -d '_' -f2)
            if [ -z "$DEVICE" ]; then
                DEVICE=$(grep ro.product."$TREE".name "$TREE_SPARSE"/build.prop | cut -d '_' -f2)
            fi
            if [ -z "$DEVICE" ]; then
                echo "Could not parse device name from $TREE_SPARSE/build.prop"
                exit 1
            fi
            mkdir -p "$DEVICE"/"$TREE"
            mv "$TREE_SPARSE"/build.prop "$DEVICE"/"$TREE"

            if [ -f "$TREE_SPARSE"/odm/etc/build.prop ]; then
                mkdir -p "$DEVICE"/"$TREE"/odm/etc
                mv "$TREE_SPARSE"/odm/etc/build.prop "$DEVICE"/"$TREE"/odm/etc
            fi
        fi
    elif [ "$TREE" = "system_ext" ]; then
        if [ -f "$TREE_SPARSE"/build.prop ]; then
            DEVICE=$(grep ro."$TREE".product.name "$TREE_SPARSE"/build.prop | cut -d '_' -f3)
            if [ -z "$DEVICE" ]; then
                DEVICE=$(grep ro.product."$TREE".name "$TREE_SPARSE"/build.prop | cut -d '_' -f3)
            fi
            if [ -z "$DEVICE" ]; then
                echo "Could not parse device name from $TREE_SPARSE/build.prop"
                exit 1
            fi
            mkdir -p "$DEVICE"/"$TREE"
            mv "$TREE_SPARSE"/build.prop "$DEVICE"/"$TREE"
        fi
    fi

    if [ "$TREE" = "product" ] || [ "$TREE" = "vendor" ] || [ "$TREE" = "system_ext" ]; then
        # Move Vendor Interface Object manifest to proper place
        if [ -f "$TREE_SPARSE"/etc/vintf/manifest.xml ]; then
            mkdir -p "$DEVICE"/"$TREE"/etc/vintf
            mv "$TREE_SPARSE"/etc/vintf/manifest.xml "$DEVICE"/"$TREE"/etc/vintf/manifest.xml
        fi
    fi
fi

# Apply patches if exist
if [ -d patches-"$TREE" ]; then
    echo "Apply patches:"
    for p in patches-"$TREE"/*; do
        patch -p1 -f -i "$p"
    done
fi

done  # for tree_mount in "${trees[@]}"; do
